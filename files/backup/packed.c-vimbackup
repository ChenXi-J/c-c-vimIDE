#include <string.h>
#include <stdio.h>
#include <arpa/inet.h>
#include "packed.h"
#include "unpacked.h"
#include "main.h"
#include "verify.h"

//暂时的设备id
uint8_t device_id[] = {0x67,0x32,0x19,0x00,0x10,0x01};

//消息流水号
uint16_t g_send_index = 0;

uint16_t packed_addTag(uint8_t* databuf, uint16_t databuflen)
{
	uint8_t bufTmp[PACKET_BODYMAXLEN] = {0};

	bufTmp[0] = PACKET_TAG;
	memcpy(bufTmp+1, databuf, databuflen);
	bufTmp[databuflen + 1] = PACKET_TAG;

	memcpy(databuf, bufTmp, databuflen+2);

	return databuflen+2;
}

uint16_t packed_addVerify(uint8_t* databuf, uint16_t databuflen)
{
	databuf[databuflen] = checkSum(databuf, databuflen);

	return databuflen+1;
}

uint16_t packed_escape(uint8_t* databuf, uint16_t databuflen)
{
	uint8_t bufTmp[PACKET_BODYMAXLEN] = {0};
	uint16_t bufTmpLen = 0, len =0;

	do
	{
		if (databuf[len] == 0x7d)
		{
			bufTmp[bufTmpLen] = 0x7d;
			bufTmpLen += 1;
			bufTmp[bufTmpLen] = 0x01;
		}
		else if (databuf[len] == 0x7e)
		{
			bufTmp[bufTmpLen] = 0x7d;
			bufTmpLen += 1;
			bufTmp[bufTmpLen] = 0x02;
		}
		else
		{
			bufTmp[bufTmpLen] = databuf[len];
		}

		len++;
		bufTmpLen++;
	}while(len < databuflen);

	memcpy(databuf, bufTmp, bufTmpLen);
	return bufTmpLen;
}

//打包消息头和消息体
uint16_t packed_headerAndBody(uint16_t id, uint8_t* databuf, uint16_t databuflen, uint16_t packAllNum, uint16_t packNum)
{
	uint8_t bufTmp[PACKET_BODYMAXLEN] = {0};
	uint16_t bufTmpLen = 0;

	*(uint16_t*)(bufTmp+bufTmpLen) = htons(id); //消息id
	bufTmpLen += 2;

	if(packAllNum != 0)
	{
		databuflen |= 1<<13; //需要分包
	}
	*(uint16_t*)(bufTmp+bufTmpLen) = htons(databuflen); //消息体属性
	bufTmpLen += 2;

	memcpy(bufTmp+bufTmpLen, device_id, 6);  //终端手机号
	bufTmpLen += 6;

	*(uint16_t*)(bufTmp+bufTmpLen) = htons(++g_send_index); //消息流水号
	bufTmpLen += 2;

	if(packAllNum != 0)
	{
		*(uint16_t*)(bufTmp+bufTmpLen) = htons(packAllNum); //消息流水号
		bufTmpLen += 2;
		*(uint16_t*)(bufTmp+bufTmpLen) = htons(packNum); //消息流水号
		bufTmpLen += 2;
	}

	memcpy(bufTmp+bufTmpLen, databuf, databuflen);
	bufTmpLen += databuflen;

	memcpy(databuf, bufTmp, bufTmpLen);
	return bufTmpLen;
}

uint16_t packed(uint16_t id, uint8_t *buf, uint16_t *len, uint16_t packAllNum, uint16_t packNum)
{
	*len = packed_headerAndBody(id, buf, *len, packAllNum, packNum);
	*len = packed_addVerify(buf, *len);
	*len = packed_escape(buf, *len);
	*len = packed_addTag(buf, *len);

	return *len;
}
