/*
 * CTRL driver for GPIOs
 *
 * Copyright (C) 2007 8D Technologies inc.
 * Raphael Assenat <raph@8d.com>
 * Copyright (C) 2008 Freescale Semiconductor, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */
#include <linux/err.h>
#include <linux/gpio.h>
#include <linux/gpio/consumer.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/of.h>
#include <linux/of_gpio.h>
#include <linux/platform_device.h>
#include <linux/property.h>
#include <linux/slab.h>
#include <linux/workqueue.h>
#include <linux/interrupt.h>
#include <asm/uaccess.h>

#define CTRL_MAJOR	191
#define CTRL_ON		1
#define CTRL_OFF		0

#define CTRL_MAGIC			't'
#define CTRL_ON_ALL_CMD				_IOW(CTRL_MAGIC, 0x00, int)
#define CTRL_OFF_ALL_CMD			_IOW(CTRL_MAGIC, 0xff, int)
#define CTRL_ENABLE_CAMMERA_CMD		_IOW(CTRL_MAGIC, 0x01, int)
#define CTRL_DISABLE_CAMMERA_CMD	_IOW(CTRL_MAGIC, 0x02, int)
#define CTRL_RESET_GPS_CMD			_IOW(CTRL_MAGIC, 0x03, int)

#define CTRL_ACC_INTTIME_CMD		_IOW(CTRL_MAGIC, 0x04, int)
#define CTRL_DOOR_INTTIME_CMD		_IOW(CTRL_MAGIC, 0x05, int)
#define CTRL_SIMCH_INTTIME_CMD		_IOW(CTRL_MAGIC, 0x06, int)

#define CTRL_485_RECV_CMD			_IOW(CTRL_MAGIC, 0x07, int)
#define CTRL_485_SEND_CMD			_IOW(CTRL_MAGIC, 0x08, int)

#define GPIO_LEN 5
#define IRQ_GPIO_LEN 6

typedef void (*interrupt_fun)(void *arg);

char *gpio_label[] = { //不能变顺序
	"usb2-en",
	"usb3-en",
	"typec0-en",
	"cs-485",
	"gps-rst",
};

char *irq_label[] = {
	"alm-acc",
	"alm-sig1",
	"alm-sig2",
	"alm-sig3",
	"alm-sig4",
	"sim-ch",
};

struct Ctrl_Dev {
	int gpio[GPIO_LEN];
	enum of_gpio_flags gpio_flag[GPIO_LEN];
	int irq_gpio[IRQ_GPIO_LEN];
	enum of_gpio_flags irq_flag[IRQ_GPIO_LEN];
} *ctrl_dev;

struct ctrl_data_t{
	char *name;
	int gpio;
	int irq;
	struct timer_list timer;
	int delay;  // 每10ms
	bool arrive; // 接收到中断置位
}*irq_data;

static struct fasync_struct *ctrl_fasync;
static struct timer_list gps_timer;
static bool is_open = false;

static irqreturn_t ctrl_interrupt(int irq, void *arg)
{
	struct ctrl_data_t *data = arg;
	printk(KERN_NOTICE "%s enter, %s: gpio:%d, irq: %d\n", __func__, data->name, data->gpio, data->irq);

	mod_timer(&data->timer,jiffies+(HZ/100*data->delay));

	return IRQ_HANDLED;
}

static void ctrl_fasync_fun(unsigned long arg)
{
	int index = 0;
	struct ctrl_data_t *data = (struct ctrl_data_t*)arg;

	for(index = 0; index<IRQ_GPIO_LEN; index++)
	{
		if(data->gpio == ctrl_dev->irq_gpio[index])
		{
			break;
		}
	}

	if(ctrl_dev->irq_flag[index] == IRQF_TRIGGER_FALLING)
	{
		if(gpio_get_value(ctrl_dev->irq_gpio[index]) == 0)
		{
			printk(KERN_ERR "%s:send fasync gpiol:%d index:%d\n",__FILE__,gpio_get_value(ctrl_dev->irq_gpio[index]), index);
			data->arrive = true;
			kill_fasync(&ctrl_fasync, SIGIO, POLL_IN);
		}
	}
	else if(ctrl_dev->irq_flag[index] == IRQF_TRIGGER_RISING)
	{
		if(gpio_get_value(ctrl_dev->irq_gpio[index]) > 0)
		{
			printk(KERN_ERR "%s:send fasync gpior:%d index:%d\n",__FILE__,gpio_get_value(ctrl_dev->irq_gpio[index]), index);
			data->arrive = true;
			kill_fasync(&ctrl_fasync, SIGIO, POLL_IN);
		}
	}
	else
	{
			printk(KERN_ERR "%s:send fasync gpiob:%d index:%d\n",__FILE__,gpio_get_value(ctrl_dev->irq_gpio[index]), index);
		data->arrive = true;
		kill_fasync(&ctrl_fasync, SIGIO, POLL_IN);
	}

}

static void gps_timer_handle(unsigned long arg)
{
	printk(KERN_ERR "%s:gps timer\n",__FILE__);

	if(ctrl_dev->gpio_flag[4] != OF_GPIO_ACTIVE_LOW)
	{
		gpio_set_value(ctrl_dev->gpio[4], CTRL_ON);
	}
	else
	{
		gpio_set_value(ctrl_dev->gpio[4], CTRL_OFF);
	}
}

static int ctrl_gpio_init(void)
{
	int i;

	for(i=0; i< GPIO_LEN; i++)
	{
		if(gpio_request(ctrl_dev->gpio[i], gpio_label[i]))
		{
			printk(KERN_ERR "%s: %s is request failed\n",__FILE__, gpio_label[i]);
			gpio_free(ctrl_dev->gpio[i]);
			return -ENODEV;
		}

		if(ctrl_dev->gpio_flag[i] != OF_GPIO_ACTIVE_LOW)
		{
			gpio_direction_output(ctrl_dev->gpio[i], CTRL_ON);
		}
		else
		{
			gpio_direction_output(ctrl_dev->gpio[i], CTRL_OFF);
		}
	}

	return 0;
}

static int ctrl_irq_init(void)
{
	int i;
	int irq;
	int ret = 0;


	irq_data = (struct ctrl_data_t*)kmalloc(sizeof(struct ctrl_data_t)*IRQ_GPIO_LEN, GFP_KERNEL);
	if(!irq_data)
	{
		printk(KERN_ERR "%s: Driver init kmalloc failed\n", __FILE__);
	}

	printk(KERN_NOTICE "%s: Driver init irq\n", __FILE__);

	for(i=1; i< IRQ_GPIO_LEN; i++)
	{
		irq = gpio_to_irq(ctrl_dev->irq_gpio[i]);

		if(irq)
		{
			if(gpio_request(ctrl_dev->irq_gpio[i], irq_label[i]))
			{
				printk(KERN_ERR "%s: %s is request failed\n",__FILE__, irq_label[i]);
				gpio_free(ctrl_dev->irq_gpio[i]);
				return -ENODEV;
			}

			irq_data[i].name = irq_label[i];
			irq_data[i].gpio = ctrl_dev->irq_gpio[i];
			irq_data[i].irq	 = irq;
			irq_data[i].delay = 5;
			irq_data[i].arrive = false;

			ret = request_irq(irq, ctrl_interrupt
					, ctrl_dev->irq_flag[i], irq_label[i], irq_data+i);
			if (ret != 0) {
				free_irq(irq, irq_data+i);
				printk(KERN_ERR "%s: %s is irq request failed\n",__FILE__, irq_label[i]);
			}

			init_timer(&irq_data[i].timer);
			irq_data[i].timer.data = (unsigned long)(&irq_data[i]);
			irq_data[i].timer.function = ctrl_fasync_fun;
			add_timer(&irq_data[i].timer);  //会触发发送信号 需要防止

		}
		else
		{
				printk(KERN_ERR "%s: %s is irq get failed\n",__FILE__, irq_label[i]);
		}

	}

	return ret;

}

static void ctrl_gpio_destroy(void)
{
	int i;
	for(i=0; i< GPIO_LEN; i++)
	{
		gpio_direction_output(ctrl_dev->gpio[i], CTRL_OFF);
		gpio_free(ctrl_dev->gpio[i]);
	}

}

static void ctrl_irq_destroy(void)
{
	int i;
	for(i=1; i< IRQ_GPIO_LEN; i++)
	{
		if(irq_data != NULL)
		{
			free_irq(gpio_to_irq(ctrl_dev->irq_gpio[i]), irq_data+i);
			del_timer(&irq_data[i].timer);
		}
		gpio_free(ctrl_dev->irq_gpio[i]);
	}

	if(irq_data != NULL)
	{
		kfree(irq_data);
		irq_data = NULL;
	}

}

static long ctrldev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	int i;
	switch(cmd)
	{
		case CTRL_ON_ALL_CMD:
			printk(KERN_ERR "%s: Driver ON\n", __FILE__);
			for(i=0; i< GPIO_LEN; i++)
			{
				if(ctrl_dev->gpio_flag[i] != OF_GPIO_ACTIVE_LOW)
				{
					gpio_set_value(ctrl_dev->gpio[i], CTRL_ON);
				}
				else
				{
					gpio_set_value(ctrl_dev->gpio[i], CTRL_OFF);
				}

			}
			break;
		case CTRL_OFF_ALL_CMD:
			printk(KERN_ERR "%s: Driver OFF\n", __FILE__);
			for(i=0; i< GPIO_LEN; i++)
			{
				if(ctrl_dev->gpio_flag[i] == OF_GPIO_ACTIVE_LOW)
				{
					gpio_set_value(ctrl_dev->gpio[i], CTRL_ON);
				}
				else
				{
					gpio_set_value(ctrl_dev->gpio[i], CTRL_OFF);
				}
			}

			break;
		case CTRL_ENABLE_CAMMERA_CMD:
				printk(KERN_ERR "%s: Driver ENABLE CAMMERA\n", __FILE__);
				if(ctrl_dev->gpio_flag[0] != OF_GPIO_ACTIVE_LOW)
				{
					gpio_set_value(ctrl_dev->gpio[0], CTRL_ON);
				}
				else
				{
					gpio_set_value(ctrl_dev->gpio[0], CTRL_OFF);
				}

				if(ctrl_dev->gpio_flag[1] != OF_GPIO_ACTIVE_LOW)
				{
					gpio_set_value(ctrl_dev->gpio[1], CTRL_ON);
				}
				else
				{
					gpio_set_value(ctrl_dev->gpio[1], CTRL_OFF);
				}
			break;
		case CTRL_DISABLE_CAMMERA_CMD:
				printk(KERN_ERR "%s: Driver DISABLE CAMMERA\n", __FILE__);
				if(ctrl_dev->gpio_flag[0] == OF_GPIO_ACTIVE_LOW)
				{
					gpio_set_value(ctrl_dev->gpio[0], CTRL_ON);
				}
				else
				{
					gpio_set_value(ctrl_dev->gpio[0], CTRL_OFF);
				}


				if(ctrl_dev->gpio_flag[1] == OF_GPIO_ACTIVE_LOW)
				{
					gpio_set_value(ctrl_dev->gpio[1], CTRL_ON);
				}
				else
				{
					gpio_set_value(ctrl_dev->gpio[1], CTRL_OFF);
				}
			break;
		case CTRL_RESET_GPS_CMD:
				printk(KERN_ERR "%s: Driver RESET GPS CAMMERA\n", __FILE__);
				if(ctrl_dev->gpio_flag[4] == OF_GPIO_ACTIVE_LOW)
				{
					gpio_set_value(ctrl_dev->gpio[4], CTRL_ON);
				}
				else
				{
					gpio_set_value(ctrl_dev->gpio[4], CTRL_OFF);
				}
				mod_timer(&gps_timer, jiffies+(HZ*2)); //延迟2秒
			break;
		case CTRL_485_RECV_CMD:
				printk(KERN_ERR "%s: Driver 485 RECV\n", __FILE__);
				gpio_set_value(ctrl_dev->gpio[3], CTRL_OFF);
			break;
		case CTRL_485_SEND_CMD:
				printk(KERN_ERR "%s: Driver 485 SEND\n", __FILE__);
				gpio_set_value(ctrl_dev->gpio[3], CTRL_ON);
			break;
		case CTRL_ACC_INTTIME_CMD:
			irq_data[0].delay = arg;
			printk(KERN_ERR "%s: Driver ACC INT TIME:%d\n", __FILE__,irq_data[0].delay);
			break;
		case CTRL_DOOR_INTTIME_CMD:
			irq_data[1].delay = arg;
			irq_data[2].delay = arg;
			irq_data[3].delay = arg;
			irq_data[4].delay = arg;
			printk(KERN_ERR "%s: Driver DOOR INT TIME:%d\n", __FILE__,irq_data[1].delay);
			break;
		case CTRL_SIMCH_INTTIME_CMD:
			irq_data[5].delay = arg;
			printk(KERN_ERR "%s: Driver SIMCH INT TIME:%d\n", __FILE__,irq_data[5].delay);
			break;


	}

	return 0;
}

static int ctrldev_open(struct inode *inode, struct file *file)
{
	printk(KERN_NOTICE "%s: Driver open start\n", __FILE__);

	if(is_open)
	{
		return 0;
	}

	is_open = true;
	if(ctrl_irq_init())
	{
		printk(KERN_ERR "%s: Driver open irq failed", __FILE__);
	}

	printk(KERN_NOTICE "%s: Driver open success\n", __FILE__);


	return 0;
}

static int ctrldev_release(struct inode *inode, struct file *file)
{

	printk(KERN_NOTICE "%s: Driver release start\n", __FILE__);

	ctrl_irq_destroy();
	is_open = false;

	printk(KERN_NOTICE "%s: Driver release success\n", __FILE__);

	return 0;
}

static int ctrldev_fasync(int fd, struct file *file, int on)
{
	return fasync_helper(fd, file, on,&ctrl_fasync);
}

//前6字节为发送了什么中断 后6字节为引脚电平
static ssize_t ctrldev_read(struct file *file, char __user *buf, size_t count,loff_t * ppos)
{
	int i;
	int num = count;
	char kernbuf[IRQ_GPIO_LEN*2]={0};

	if(num > IRQ_GPIO_LEN*2)
	{
		num = IRQ_GPIO_LEN*2;
	}
	for( i=0; i< num; i++)
	{
		if(i<IRQ_GPIO_LEN)
		{
			if(irq_data[i].arrive)
			{
				kernbuf[i] = 1;
				irq_data[i].arrive = false;  //应用接受到中断复位
			}
		}
		else
		{
			kernbuf[i] = gpio_get_value(ctrl_dev->irq_gpio[i-IRQ_GPIO_LEN]);
		}
	}

	if(copy_to_user(buf,kernbuf,num))
	{
		return EFAULT;
	}

	return num;

}

static const struct file_operations ctrldev_fops = {
	.owner			= THIS_MODULE,
	.open			= ctrldev_open,
	.read			= ctrldev_read,
	.unlocked_ioctl	= ctrldev_ioctl,
	.release		= ctrldev_release,
	.fasync			= ctrldev_fasync,
};

static const struct of_device_id of_gpio_ctrls_match[] = {
	{ .compatible = "gpio_apc_ctrl", },
	{},
};

MODULE_DEVICE_TABLE(of, of_gpio_ctrls_match);

static int gpio_ctrl_valid(int gpio,char *label)
{
	if(!gpio_is_valid(gpio)) {
		printk("%s: %d,%s is invalid\n",__FILE__, gpio, label);
		return -ENODEV;
	}

	return 0;
}

static struct class *ctrl_dev_class;

static int gpio_ctrl_probe(struct platform_device *pdev)
{
	int res;
	int i;
	struct device_node *gpio_node = pdev->dev.of_node;

	res = register_chrdev(CTRL_MAJOR, "gpio_ctrl", &ctrldev_fops);
	if(res)
		goto out;

	ctrl_dev_class = class_create(THIS_MODULE, "ctrl-dev");
	if(IS_ERR(ctrl_dev_class)) {
		res = PTR_ERR(ctrl_dev_class);
		goto out_unreg_chrdev;
	}

	device_create(ctrl_dev_class, NULL, MKDEV(CTRL_MAJOR, 1), NULL, "gpio_ctrl");

	ctrl_dev = kmalloc(sizeof(struct Ctrl_Dev), GFP_KERNEL);
	if(!ctrl_dev) {
		goto out_unclass;
	}

	for(i = 0; i< GPIO_LEN; i++)
	{
		ctrl_dev->gpio[i]= of_get_named_gpio_flags(gpio_node, gpio_label[i], 0, &ctrl_dev->gpio_flag[i]);
		if(gpio_ctrl_valid(ctrl_dev->gpio[i], gpio_label[i])) {
			goto out_kmalloc;
		}

	}

	for(i = 0; i< IRQ_GPIO_LEN; i++)
	{
		ctrl_dev->irq_gpio[i]= of_get_named_gpio_flags(gpio_node, irq_label[i], 0, &ctrl_dev->irq_flag[i]);
		if(gpio_ctrl_valid(ctrl_dev->irq_gpio[i], irq_label[i])) {
			goto out_kmalloc;
		}
	}

	if(ctrl_gpio_init())
	{
		goto out_kmalloc;
	}
	


	init_timer(&gps_timer);
	gps_timer.function = gps_timer_handle;
	add_timer(&gps_timer);  //会触发发送信号 需要防止

	printk(KERN_ERR "%s: Driver init success\n", __FILE__);

	return 0;

out_kmalloc:
	printk(KERN_ERR "%s: Driver invalid \n", __FILE__);
	kfree(ctrl_dev);
out_unclass:
	printk(KERN_ERR "%s: Driver  malloc failed\n", __FILE__);
	class_destroy(ctrl_dev_class);
out_unreg_chrdev:
	unregister_chrdev(CTRL_MAJOR, "gpio-ctrl");
	printk(KERN_ERR "%s: Driver  class failed\n", __FILE__);
out:
	printk(KERN_ERR "%s: Driver init failed\n", __FILE__);

	return res;
}

static int gpio_ctrl_remove(struct platform_device *pdev)
{
	ctrl_gpio_destroy();
	ctrl_irq_destroy();

	del_timer(&gps_timer);

	class_destroy(ctrl_dev_class);
	unregister_chrdev(CTRL_MAJOR, "gpio_ctrl");

	kfree(ctrl_dev);

	return 0;
}

static struct platform_driver gpio_ctrl_driver = {
	.probe		= gpio_ctrl_probe,
	.remove		= gpio_ctrl_remove,
	.driver		= {
		.name	= "gpio_apc_ctrl",
		.of_match_table = of_gpio_ctrls_match,
	},
};

module_platform_driver(gpio_ctrl_driver);

MODULE_AUTHOR("csf");
MODULE_DESCRIPTION("GPIO CTRL driver");
MODULE_LICENSE("GPL");
MODULE_ALIAS("platform:ctrls-apc");
