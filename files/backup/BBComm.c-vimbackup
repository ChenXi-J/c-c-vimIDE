#include "stdlib.h"
#include "includes.h"
#include "bsp.h"
#include "app.h"
#include "gprs.h"
#include "BBComm.h"
#include "fun.h"
#include "usart.h"

extern OS_EVENT* 		DSP_Q;
extern OS_EVENT*		DSP_VER_SEM;
extern SYS_INFO		 	SysInfo;
extern SYS_CFG		 	SysCfg;
extern AUTHEN_INFO 	AuthenInfo;
extern BB_RX_BUF		BBRxBuf;
extern BB_RX_ESC    BBRxEsc;
extern FILE_INFO		FileInfo;
extern DSP_MESS			MsgArray[20];
extern const u32  	ARMVerNum;
extern volatile u32 DSPVerNum;
extern volatile u8  RunModeFlag;
extern volatile u8  GpsLocOkf;
extern volatile u8  BBFlagGetServer;
extern volatile u8  BBFlagRegister;
extern volatile u8  BBFlagAuthen;
extern volatile u8  BBFlagLocate;
extern volatile u8  BBFlagVersion;
extern volatile u8  BBFlagDtu;
extern volatile u8  BBFlagUpdata;
extern volatile u8  BBFlagJpg;

extern u8   				GprsTxBuf[BB_TX_BUF_LEN];
extern u8   				DSP1TxBuf[DSP_TX_BUF_LEN];
extern u8   				DSP2TxBuf[DSP_TX_BUF_LEN];
extern u16  				BBSendIndex;
extern u32  				DSP1VerNum;
extern u32  				DSP2VerNum;

u8			BBTxEsc[BB_TX_ESC_LEN];										// 部标规定消息体最大长度为1024字节，因此部标消息的临时缓存最大设为1460字节

//计算校验码
u8 CheckSum(u8* buff,int length)
{
	int i;
	u8 sum = 0;

	for (i = 0; i < length; i++)
	{
		sum ^= buff[i];
	}

	return sum;
}

// 数据反向转码
int BB_ReEscapeData(u8 *dst,u8* source,int length)
{
	u8 subNum = 0;
	int index = 0;
	for(index = 0; index < length; index++)
	{
		if(source[index] == 0x7d)
		{
			if(source[index+1] == 0x01)
			{
				dst[index-subNum] = 0x7d;
				subNum++;
				index++;
			}
			else if(source[index+1] == 0x02)
			{
				dst[index-subNum] = 0x7e;
				subNum++;
				index++;
			}
		}
		else
		{
			dst[index-subNum] = source[index];
		}
	}

	return length - subNum;
}
//数据转码
int BB_EscapeData(u8 *dst,u8* source,int length)
{
	u8 addNum = 0;
	int index = 0;

	for(index = 0; index < length; index++)
	{
		if ( source[index] == 0x7d)
		{
			dst[index+addNum] = 0x7d;
			addNum += 1;
			dst[index+addNum] = 0x01;
		}
		else if (source[index] == 0x7e)
		{
			dst[index+addNum] = 0x7d;
			addNum += 1;
			dst[index+addNum] = 0x02;
		}
		else
		{
			dst[index+addNum] = source[index];
		}
	}

	return length+addNum;
}


int BB_MsgSend(u8* xmtData, u8 *msgData, u16 msgLen, u16 msgId, u16 msgIndex)   ///给data1加包头、校、包尾、返回包长度
{
		int i = 0;
		u16 tmpLen=0;
		u16 xmtLen=0;
	
		if(msgLen>BB_MESS_LEN)					// 部标消息头中消息体长度最大有1000字节限制
		{
			return 0;
		}
				 
		BBTxEsc[0] = (msgId&0xff00)>>8;
		BBTxEsc[1] = msgId&0x00ff;
		BBTxEsc[2] = (msgLen>>8)&0xFF;
		BBTxEsc[3] = msgLen&0xFF;

		//终端手机号，设备ID
		BBTxEsc[4] = SysCfg.phNum[0];
		BBTxEsc[5] = SysCfg.phNum[1];
		BBTxEsc[6] = SysCfg.phNum[2];
		BBTxEsc[7] = SysCfg.phNum[3];
		BBTxEsc[8] = SysCfg.phNum[4];
		BBTxEsc[9] = SysCfg.phNum[5];
		//++消息流水号
		BBTxEsc[10] = (u8)((msgIndex & 0xFF00) >> 8);
		BBTxEsc[11] = (u8)(msgIndex & 0x00FF);
	
		for(i = 0;i < msgLen;i++)                           //add head
		{
			BBTxEsc[i+12] = msgData[i];
		}
		tmpLen = 12 + msgLen;											// 消息头12字节+消息内容


		BBTxEsc[tmpLen] = CheckSum(BBTxEsc, tmpLen);			//填充校验码
		tmpLen++;																	// 校验码1字节

		xmtLen = BB_EscapeData(&xmtData[1], BBTxEsc, tmpLen);	// 转义

		xmtLen+=2;																// 添加2字节的标识符
		xmtData[0] = 0x7e;
		xmtData[xmtLen-1] = 0x7e;

		if(send_gprs_data(xmtData, xmtLen))
			return TRUE;
		else
			return FALSE;
}

int BB_GetServers(void)
{
	u16  bb_cnt=0;
	BBFlagGetServer = FALSE;
	BB_MsgSend(GprsTxBuf, NULL, 0, 0x0F05, 0);// 获取新服务器IP
	while(BBFlagGetServer != TRUE)			// 循环查询标志位，设一定超时时间
	{
		bb_cnt++;
		if(bb_cnt > BB_COM_OVERTIMES)
		{
			break;
		}
		OSTimeDlyHMSM(0, 0, 0, 10);
	}
	if(bb_cnt > BB_COM_OVERTIMES)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}

}

int BB_RegisterSend(void)		//终端注册信息发送
{
	u16  bb_cnt=0;
	u8   RegInfoBuf[REG_BUF_LEN];
	
	memset(RegInfoBuf, 0, REG_BUF_LEN);

	RegInfoBuf[0] = 0x00;		// 省ID
	RegInfoBuf[1] = 0x32;
	RegInfoBuf[2] = 0x00;		// 市县ID
	RegInfoBuf[3] = 0x00;
	RegInfoBuf[4] = 0x38;		// 制造商ID5，5字节
	RegInfoBuf[5] = 0x38;
	RegInfoBuf[6] = 0x38;
	RegInfoBuf[7] = 0x38;
	RegInfoBuf[8] = 0x38;
	RegInfoBuf[9] = SysInfo.termType[0];	// 终端型号
	RegInfoBuf[10] = SysInfo.termType[1];

	RegInfoBuf[29] = SysInfo.termID[0];		// 终端ID，7字节
	RegInfoBuf[30] = SysInfo.termID[1];
	RegInfoBuf[31] = SysInfo.termID[2];
	RegInfoBuf[32] = SysInfo.termID[3];
	RegInfoBuf[33] = SysInfo.termID[4];
	RegInfoBuf[34] = SysInfo.termID[5];
	RegInfoBuf[35] = SysInfo.termID[6];
	RegInfoBuf[36] = 1;				// 车牌颜色
	RegInfoBuf[37] = 0xCB;		// 车牌号
	RegInfoBuf[38] = 0xD5;
	RegInfoBuf[39] = 0x45;
	RegInfoBuf[40] = 0x36;
	RegInfoBuf[41] = 0x36;
	RegInfoBuf[42] = 0x36;
	RegInfoBuf[43] = 0x36;
	RegInfoBuf[44] = 0x36;
	
	BBFlagRegister = FALSE;
	BB_MsgSend(GprsTxBuf, RegInfoBuf, 45, 0x0100, 0);// 终端注册	
	while(BBFlagRegister != TRUE)			// 循环查询标志位，设一定超时时间
	{
		bb_cnt++;
		if(bb_cnt > BB_COM_OVERTIMES)
		{
			break;
		}
		OSTimeDlyHMSM(0, 0, 0, 10);
	}
	if(bb_cnt > BB_COM_OVERTIMES)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

int BB_AuthenSend(void)				//终端鉴权信息打包
{
	u16  bb_cnt=0;
//	u8 i = 0;

	if(AuthenInfo.len > ATH_BUF_LEN)
	{
		AuthenInfo.len = ATH_BUF_LEN;
	}

	BBFlagAuthen = FALSE;
	BB_MsgSend(GprsTxBuf, AuthenInfo.buf, AuthenInfo.len, 0x0102, 0);
	while(BBFlagAuthen != TRUE)		// 循环查询标志位，设一定超时时间
	{
		bb_cnt++;
		if(bb_cnt > BB_COM_OVERTIMES)
		{
			break;
		}
		OSTimeDlyHMSM(0, 0, 0, 10);
	}
	if(bb_cnt > BB_COM_OVERTIMES)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

int BB_VerNumSend(void)
{
	INT8U err;	
	u16   bb_cnt = 0;
	u8    xmtBuf[16];
	u32   DSPVerNum = 0;
	
	ReadFileInfo(&FileInfo);
	
	DSP1VerNum=0;
	OSSemSet(DSP_VER_SEM,0,&err);
	MsgArray[DSP1_GET_VER_SYS].cmd = DSP1_GET_VER_SYS;
	OSQPost(DSP_Q, &MsgArray[DSP1_GET_VER_SYS]);
	OSSemPend(DSP_VER_SEM,5000,&err);	
	DSP2VerNum=0;
	OSSemSet(DSP_VER_SEM,0,&err);
	MsgArray[DSP2_GET_VER_SYS].cmd = DSP2_GET_VER_SYS;
	OSQPost(DSP_Q, &MsgArray[DSP2_GET_VER_SYS]);
	OSSemPend(DSP_VER_SEM,5000,&err);	
	
	if(DSP1VerNum<=DSP2VerNum)
	{
		DSPVerNum = DSP1VerNum;
	}
	else
	{
		DSPVerNum = DSP2VerNum;
	}
	
	xmtBuf[0] = (u8)VER_ARM1;
	xmtBuf[1] = (u8)VER_ARM2;
	xmtBuf[2] = (u8)VER_ARM3;
	xmtBuf[3] = (u8)VER_ARM4;
	xmtBuf[4] = (u8)(DSPVerNum>>24)&0xFF;
	xmtBuf[5] = (u8)(DSPVerNum>>16)&0xFF;
	xmtBuf[6] = (u8)(DSPVerNum>>8)&0xFF;
	xmtBuf[7] = (u8)(DSPVerNum)&0xFF;
	
	BBFlagVersion = FALSE;
	BB_MsgSend(GprsTxBuf, xmtBuf, 8, 0x0F00, BBSendIndex++);
	while(BBFlagVersion != TRUE)		// 循环查询标志位，设一定超时时间
	{
		bb_cnt++;
		if(bb_cnt > BB_COM_OVERTIMES)
		{
			break;
		}
		OSTimeDlyHMSM(0, 0, 0, 10);
	}
	if(bb_cnt > BB_COM_OVERTIMES)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

int BB_LocSend(u8* gpsLocData, u16 gpsLen)
{
	u16  bb_cnt = 0;

	BBFlagLocate = FALSE;
	BB_MsgSend(GprsTxBuf, gpsLocData, gpsLen, 0x0200, BBSendIndex++);
	while(BBFlagLocate != TRUE)		// 循环查询标志位，设一定超时时间
	{
		bb_cnt++;
		if(bb_cnt > BB_COM_OVERTIMES)
		{
			break;
		}
		OSTimeDlyHMSM(0, 0, 0, 10);
	}
	if(bb_cnt>BB_COM_OVERTIMES)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

int BB_DtuSend(u8* dtuData, u16 dtuLen)
{
	u16  bb_cnt = 0;

	BBFlagDtu = FALSE;
	BB_MsgSend(GprsTxBuf, dtuData, dtuLen, 0x0900, BBSendIndex++);
	while(BBFlagDtu != TRUE)		// 循环查询标志位，设一定超时时间
	{
		bb_cnt++;
		if(bb_cnt > BB_COM_OVERTIMES)
		{
			break;
		}
		OSTimeDlyHMSM(0, 0, 0, 10);
	}
	if(bb_cnt>BB_COM_OVERTIMES)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

int BB_JpgPackSend(u8* xmtData, u8 chId, u8 eventFlag, u8* locData, u32 jpgId, u8 *jpgData, u32 jpgLen, u16 packNum, u16 packIndex, u16 msgIndex)	
{
		u16 bb_cnt = 0;
		u16 tmp_len = 0;
		u16 xmt_len = 0;
	  u16 msg_len = 0;
	
		if(jpgLen>BB_PACK_LEN)					// 部标消息头中消息体长度最大有1024字节限制，图片分包最大不能超过980字节
		{
			return 0;
		}
	
		BBTxEsc[0] = 0x08;
		BBTxEsc[1] = 0x01;
	
		//终端手机号，设备ID
		BBTxEsc[4] = SysCfg.phNum[0];
		BBTxEsc[5] = SysCfg.phNum[1];
		BBTxEsc[6] = SysCfg.phNum[2];
		BBTxEsc[7] = SysCfg.phNum[3];
		BBTxEsc[8] = SysCfg.phNum[4];
		BBTxEsc[9] = SysCfg.phNum[5];
		//++消息流水号
		BBTxEsc[10] = (u8)((msgIndex>>8)&0xFF);
		BBTxEsc[11] = (u8)(msgIndex&0xFF);
		// 总包数
		BBTxEsc[12] = (u8)((packNum>>8)&0xFF);
		BBTxEsc[13] = (u8)(packNum&0xFF);
		// 分包序号
		BBTxEsc[14] = (u8)((packIndex>>8)&0xFF);
		BBTxEsc[15] = (u8)(packIndex&0xFF);
		
		if(packIndex==1)
		{
			// 多媒体ID
			BBTxEsc[16] = (jpgId>>24)&0xFF;
			BBTxEsc[17] = (jpgId>>16)&0xFF;
			BBTxEsc[18] = (jpgId>>8)&0xFF;
			BBTxEsc[19] = jpgId&0xFF;
			// 多媒体类型
			BBTxEsc[20] = 0x00;
			// 多媒体格式编码
			BBTxEsc[21] = 0x00;
			// 事件项编码
			BBTxEsc[22] = eventFlag;
			// 通道ID
			BBTxEsc[23] = chId;
			// 位置信息汇报
			memcpy(&BBTxEsc[24], locData, BB_LOC_LEN);
			// 图像数据
			memcpy(&BBTxEsc[24+BB_LOC_LEN], jpgData, jpgLen);
			tmp_len = 16 + 8 + BB_LOC_LEN + jpgLen;										// 消息头16字节+消息内容
		}
		else
		{
			// 图像数据
			memcpy(&BBTxEsc[16], jpgData, jpgLen);
			tmp_len = 16 + jpgLen;														// 消息头16字节+消息内容
		}

		msg_len = tmp_len - 16;
		BBTxEsc[2] = (msg_len>>8)&0xFF;
		BBTxEsc[3] = msg_len&0xFF;	
		BBTxEsc[2] |= 0x20;		
		BBTxEsc[tmp_len] = CheckSum(BBTxEsc, tmp_len);				// 填充校验码
		tmp_len++;																					// 校验码1字节

		xmt_len = BB_EscapeData(&xmtData[1], BBTxEsc, tmp_len);	// 转义

		xmt_len+=2;																				// 添加2字节的标识符
		xmtData[0] = 0x7e;
		xmtData[xmt_len-1] = 0x7e;

		bb_cnt = 0;
		BBFlagJpg = FALSE;
		send_gprs_data(GprsTxBuf, xmt_len);
		
		while(BBFlagJpg != TRUE)		// 循环查询标志位，设一定超时时间
		{
			bb_cnt++;
			if(bb_cnt > BB_COM_OVERTIMES)
			{
				break;
			}
			OSTimeDlyHMSM(0, 0, 0, 10);
		}
		if(bb_cnt>BB_COM_OVERTIMES)
		{
			UartPrintf("JPG Pack Fail.\n");
		}

		return 1;
}


int BB_UpdataPack(u8* upSeriNum, u16 fileIndex)
{
	u16   bb_cnt=0;
	u16   data_index=0;
	u8    data_buf[16];
	
	data_buf[data_index++] = upSeriNum[0];
	data_buf[data_index++] = upSeriNum[1];
	data_buf[data_index++] = upSeriNum[2];
	data_buf[data_index++] = upSeriNum[3];
	data_buf[data_index++] = upSeriNum[4];
	data_buf[data_index++] = upSeriNum[5];
	data_buf[data_index++] = upSeriNum[6];
	data_buf[data_index++] = upSeriNum[7];
	data_buf[data_index++] = (fileIndex>>8)&0xFF;
	data_buf[data_index++] = fileIndex&0xFF;
	bb_cnt = 0;
	BBFlagUpdata = BB_UPDATA_INITIAL;
	BB_MsgSend(GprsTxBuf, data_buf, data_index, 0x0F02, BBSendIndex++);
	while((BBFlagUpdata != BB_UPDATA_DATA) && (BBFlagUpdata != BB_UPDATA_ERROR))		// 循环查询标志位，设一定超时时间
	{
		bb_cnt++;
		if(bb_cnt > BB_COM_OVERTIMES)
		{
			break;
		}
		OSTimeDlyHMSM(0, 0, 0, 10);
	}
	if(bb_cnt > BB_COM_OVERTIMES)
	{
		return FALSE;		
	}
	else
	{
		return TRUE;
	}
}

int BB_UpdataOver(u8* upSeriNum, u8 upFlag)
{
	u16   bb_cnt=0;
	u16   data_index=0;
	u8    data_buf[16];
	
	data_buf[data_index++] = upSeriNum[0];
	data_buf[data_index++] = upSeriNum[1];
	data_buf[data_index++] = upSeriNum[2];
	data_buf[data_index++] = upSeriNum[3];
	data_buf[data_index++] = upSeriNum[4];
	data_buf[data_index++] = upSeriNum[5];
	data_buf[data_index++] = upSeriNum[6];
	data_buf[data_index++] = upSeriNum[7];
	data_buf[data_index++] = upFlag;
	bb_cnt = 0;
	BBFlagUpdata = BB_UPDATA_INITIAL;
	BB_MsgSend(GprsTxBuf, data_buf, data_index, 0x0F03, BBSendIndex++);
	while(BBFlagUpdata != BB_UPDATA_OVER)		// 循环查询标志位，设一定超时时间
	{
		bb_cnt++;
		if(bb_cnt > 600)								// 更新成功后，立即复位，所以只需要超时5秒等待应答
		{
			break;
		}
		OSTimeDlyHMSM(0, 0, 0, 10);
	}
	if(bb_cnt > 600)
	{
		return FALSE;		
	}
	else
	{
		return TRUE;
	}
}

void BB_ReplyDownTxMsg(u16 replyIndex)
{
	u16   data_index=0;
	u8    data_buf[16];
	
	data_buf[data_index++] = (replyIndex>>8)&0xFF;
	data_buf[data_index++] = replyIndex&0xFF;
	data_buf[data_index++] = 0x83;
	data_buf[data_index++] = 0x00;
	data_buf[data_index++] = 0x00;
	BB_MsgSend(GprsTxBuf, data_buf, data_index, 0x0001, BBSendIndex++);						
	OSTimeDlyHMSM(0,0,3,0);
}

void BB_ReplyGetRealImage(u16 replyIndex, u8 result, u32 imageId)
{
	u16   data_index=0;
	u8    data_buf[16];
	
	data_buf[data_index++] = (replyIndex>>8)&0xFF;
	data_buf[data_index++] = replyIndex&0xFF;
	data_buf[data_index++] = result;
	data_buf[data_index++] = 0x00;
	data_buf[data_index++] = 0x01;
	data_buf[data_index++] = (imageId>>24)&0xFF;
	data_buf[data_index++] = (imageId>>16)&0xFF;
	data_buf[data_index++] = (imageId>>8)&0xFF;
	data_buf[data_index++] = imageId&0xFF;
	BB_MsgSend(GprsTxBuf, data_buf, 9, 0x0805, BBSendIndex++);
	OSTimeDlyHMSM(0,0,3,0);
}



