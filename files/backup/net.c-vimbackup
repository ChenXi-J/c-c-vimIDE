#define LOG_TAG    "net"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <error.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <elog.h>
#include <signal.h>
#include <sys/stat.h>
#include <fcntl.h>


#include "recvfun.h"
#include "net.h"
#include "sendneed.h"
#include "sendfun.h"
#include "unpacked.h"
#include "verify.h"
#include "gps.h"
#include "sem.h"
#include "uart485.h"


static uint16_t in_total,out_total;
static char s_server_ip[17]; //当前连接的ip和端口
static uint16_t s_port;
bool needSendPeople;
static bool s_needDisplay = false;

uint8_t g_sendBuf[BUFSIZE], g_recvBuf[BUFSIZE];
uint16_t g_recvNum = 0, g_sendNum = 0;
int g_socketfd;
bool g_disconnect;

int g_sendSemid;
bool g_loginSuccess = false;

sysInfoStu g_sysInfo;

bool net_socketConnect(char *ip,uint16_t port)
{
	struct sockaddr_in serverAddr;

	memcpy(s_server_ip, ip, 17); //保存当前连接的地址
	s_port = port;

	if((g_socketfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		log_e("socket create fail");
		return false;
	}

	serverAddr.sin_family = AF_INET;
	serverAddr.sin_port = htons(s_port);
	serverAddr.sin_addr.s_addr = inet_addr(s_server_ip);

	if(connect(g_socketfd, (struct sockaddr*)&serverAddr,sizeof(struct sockaddr)))
	{
		log_e("connect fail\n");
		return false;
	}

	g_disconnect = false;
	return true;
}

void net_socketClose(void)
{
	g_loginSuccess = false;
	g_disconnect = true;
	close(g_socketfd);
}

void net_socketReconnect(void)
{
	while(g_disconnect == true) //尝试重连
	{
		if(!net_socketConnect(SERVER_ADDR, SERVER_PORT))
		{
			net_socketClose();
			sleep(10);
		}
	}

	//连接成功
	sendneedSetCmd(TERMINAL_GETIP_CMD);
}



void* recvDealThread(void* arg)
{
	uint8_t recvone;
	bool getTag = false;
	uint16_t cmd;

	while(1)
	{
		g_recvNum = 0;
		getTag = false;
		while(1)
		{

			if(recv(g_socketfd, &recvone, 1, 0) <= 0)
			{
				log_e("recv error (maybe disconnect)");
				net_socketClose();

				net_socketReconnect();
				g_recvNum = 0;
				getTag = false;
				continue;
			}

			if(recvone == PACKET_TAG)
			{
				if(getTag)//再次收到tag
				{
					//防止丢包后头不对应 会导致无限循环
					if(g_recvNum < PACKET_HEADERLEN1)
					{
						g_recvNum = 0;
					}
					else
					{
						break;
					}
				}

				getTag = true; //开始接收数据
			}
			else if(getTag)
			{
				g_recvBuf[g_recvNum++] = recvone;
			}
		}

		g_recvNum = unpacked_reEscape(g_recvBuf, g_recvNum);

		cmd = ntohs(*((uint16_t*)g_recvBuf));

		log_d("recv cmd:%x",cmd);
		//验证校验
		if(checkSum(g_recvBuf, g_recvNum-1) != g_recvBuf[g_recvNum - 1]) continue;

		recvfunRun(cmd);

	}

}

void* sendDealThread(void* arg)
{
	while(1)
	{
		if(sendneedSemBlock())
		{
			sem_p(g_sendSemid);
		}

		if(g_disconnect)
		{
			sleep(1);
			continue;
		}

		sendfunRun();
		sleep(1);
	}
}

void cmd_signal(int signame)
{
	log_d("recv send people");
	needSendPeople = true;
}


static void log_init(void)
{
    /* close printf buffer */
    setbuf(stdout, NULL);
    /* initialize EasyLogger */
    elog_init();
    /* set EasyLogger log format */
    elog_set_fmt(ELOG_LVL_ASSERT, ELOG_FMT_ALL);
    elog_set_fmt(ELOG_LVL_ERROR, ELOG_FMT_LVL | ELOG_FMT_TAG | ELOG_FMT_TIME | ELOG_FMT_FUNC | ELOG_FMT_LINE);
    elog_set_fmt(ELOG_LVL_WARN, ELOG_FMT_LVL | ELOG_FMT_TAG | ELOG_FMT_TIME | ELOG_FMT_FUNC | ELOG_FMT_LINE);
    elog_set_fmt(ELOG_LVL_INFO, ELOG_FMT_LVL | ELOG_FMT_TAG | ELOG_FMT_TIME | ELOG_FMT_FUNC | ELOG_FMT_LINE);
    elog_set_fmt(ELOG_LVL_DEBUG, ELOG_FMT_LVL | ELOG_FMT_TAG | ELOG_FMT_TIME | ELOG_FMT_FUNC | ELOG_FMT_LINE);
    elog_set_fmt(ELOG_LVL_VERBOSE, ELOG_FMT_LVL | ELOG_FMT_TAG | ELOG_FMT_TIME | ELOG_FMT_FUNC | ELOG_FMT_LINE);
#ifdef ELOG_COLOR_ENABLE
    elog_set_text_color_enabled(true);
#endif
    /* start EasyLogger */
    elog_start();
}


void* gpsDealThread(void* arg)
{
	while(1)
	{
		gps_getInfo(); //gps 可能会无消息 需要处理
	}
}

void* displayDealThread(void* arg)
{
	uart485_open();
	while(1)
	{
		if(s_needDisplay)
		{
			s_needDisplay = false;
			log_a("echo all %d,%d",in_total, out_total );
			uart485_echoAll(in_total, out_total, in_total-out_total);
		}
		sleep(1);
	}
}

void net_sysInfoInit(void)
{
	char buf[12];
	int read_fd=open("/root/serialnum",O_RDONLY);
	if(read_fd < 0)
	{
		log_a("read ID ERROR\n");
	}
	read(read_fd, buf,12);

	g_sysInfo.termType[0] = ((buf[0]-0x30)<<4) | (buf[1]-0x30);
	g_sysInfo.termType[1] = ((buf[2]-0x30)<<4) | (buf[3]-0x30);

	g_sysInfo.termID[0] = (((buf[4]-0x30)*10) + (buf[5]-0x30)) - 10 + 'a';
	g_sysInfo.termID[1] = buf[6];
	g_sysInfo.termID[2] = buf[7];
	g_sysInfo.termID[3] = buf[8];
	g_sysInfo.termID[4] = buf[9];
	g_sysInfo.termID[5] = buf[10];
	g_sysInfo.termID[6] = buf[11];

	close(read_fd);
}

int netProtocol(RecognitionStu *recognitionStu_shm)
{
	pthread_t send_thread, recv_thread, gps_thread, display_thread;
	uint16_t *people = malloc(4*sizeof(uint16_t));
	static uint16_t last_people_total[4] = {0};

	log_init();

	memset(people, 0,4*sizeof(uint16_t));

	int id = ftok(".", SEND_SEM_ID);
	sem_init(&g_sendSemid,id);

	sendneedInit();
	gps_init();
	net_sysInfoInit();
    signal(SIGUSR1,cmd_signal); //接受需要发送人数指令

	//net_socketConnect(SERVER_ADDR, SERVER_PORT);

	//sendneedSetCmd(TERMINAL_GETIP_CMD);
	//sendneedSetCmdArg(TERMINAL_PEOPLE_CMD,(char*)people,sizeof(4*sizeof(uint16_t)));

	//pthread_create(&recv_thread, NULL, recvDealThread, NULL);
	//pthread_create(&send_thread, NULL, sendDealThread, NULL);
	//pthread_create(&gps_thread, NULL, gpsDealThread, NULL);
	pthread_create(&display_thread, NULL, displayDealThread, NULL);

	while(1)
	{
		{
			if(recognitionStu_shm[0].people_change)
			{
				pthread_mutex_lock(&recognitionStu_shm[0].shareMtx);
				sendneedArgLock((char*)people);
				recognitionStu_shm[0].people_change = false;
				people[0] += recognitionStu_shm[0].in_total - last_people_total[0];
				people[1] += recognitionStu_shm[0].out_total - last_people_total[1];

				last_people_total[0] =recognitionStu_shm[0].in_total;
				last_people_total[1] =recognitionStu_shm[0].out_total;
				sendneedArgUnlock((char*)people);

				in_total = recognitionStu_shm[0].in_total + recognitionStu_shm[1].in_total;
				out_total = recognitionStu_shm[0].out_total + recognitionStu_shm[1].out_total;
				pthread_mutex_unlock(&recognitionStu_shm[0].shareMtx);

				s_needDisplay = true;
				log_d("frontdoorin:%d", people[0]);
				log_d("frontdoorout:%d",people[1]);
			}

			if(recognitionStu_shm[1].people_change)
			{
				pthread_mutex_lock(&recognitionStu_shm[1].shareMtx);
				sendneedArgLock((char*)people);
				recognitionStu_shm[1].people_change = false;
				people[2] += recognitionStu_shm[1].in_total - last_people_total[2];
				people[3] += recognitionStu_shm[1].out_total - last_people_total[3];

				last_people_total[2] = recognitionStu_shm[1].in_total;
				last_people_total[3] = recognitionStu_shm[1].out_total;
				sendneedArgUnlock((char*)people);

				in_total = recognitionStu_shm[0].in_total + recognitionStu_shm[1].in_total;
				out_total = recognitionStu_shm[0].out_total + recognitionStu_shm[1].out_total;
				pthread_mutex_unlock(&recognitionStu_shm[1].shareMtx);

				s_needDisplay = true;
				log_d("backdoorin:%d", people[2]);
				log_d("backdoorout:%d", people[3]);
			}

			if(needSendPeople && g_loginSuccess)
			{
				needSendPeople = false;
				sendneedSetCmd(TERMINAL_PEOPLE_CMD);
			}

		}

		sleep(1); //需要改成条件变量
	}
	//pthread_join(recv_thread, NULL);
	//pthread_join(send_thread, NULL);
	//pthread_join(gps_thread, NULL);
	pthread_join(display_thread, NULL);

	log_a("net end");

	uart485_close();
	sem_del(g_sendSemid);

	close(g_socketfd);

	return 0;

}
